name: CICD

on:
  workflow_dispatch:
    inputs:
      packages:
        description: 'Package names to build (optional, comma separated)'
        required: false
        default: ''
      release:
        description: 'Trigger release workflow (optional, boolean)'
        required: false
        type: boolean
        default: false
  push:
  pull_request:

jobs:
  ci_check:
    name: Check
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.should_build.outputs.should_build }}
      changed_dirs: ${{ steps.should_build.outputs.changed_dirs }}
    steps:
    - name: Checkout Source
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      with:
        ref: ${{ github.head_ref }}

    - name: Changed Files
      id: changed_files
      uses: tj-actions/changed-files@e0021407031f5be11a464abee9a0776171c79891 # v47.0.1
      with:
        dir_names: true
        dir_names_exclude_current_dir: true
        dir_names_max_depth: '1'
        separator: ","

    - name: Should Build
      id: should_build
      env:
        CHANGED_FILES: ${{ steps.changed_files.outputs.all_changed_files }}
        PACKAGES: ${{ github.event.inputs.packages }}
      shell: pwsh
      run: |
        $changed_dirs = $env:CHANGED_FILES -split ','
        Write-Host "Changed directories: $changed_dirs"
        $changed_dirs = $changed_dirs | Where-Object {
          -not $_.StartsWith('.') -and (Test-Path -Path "$_/recipe.yaml")
        }
        Write-Host "Changed packages: $changed_dirs"
        if (-not $changed_dirs -and $env:PACKAGES) {
          $changed_dirs = $env:PACKAGES -split ','
          Write-Host "Using workflow_dispatch packages: $changed_dirs"
        }
        if ($changed_dirs) {
          $changed_dirs = $changed_dirs -join ','
          Write-Host "should_build: true"
          Write-Host "changed_dirs: $changed_dirs"
          echo "should_build=true" >> $env:GITHUB_OUTPUT
          echo "changed_dirs=$changed_dirs" >> $env:GITHUB_OUTPUT
        }

  ci_matrix:
    name: Generate Matrix
    needs: ci_check
    runs-on: ubuntu-latest
    if: needs.ci_check.outputs.should_build == 'true'
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
    - name: Checkout Source
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      with:
        ref: ${{ github.head_ref }}
        fetch-depth: 1

    - name: Set Matrix
      id: set-matrix
      env:
        CHANGED_DIRS: ${{ needs.ci_check.outputs.changed_dirs }}
      shell: pwsh
      run: |
        $matrixInclude = @()
        $changed_dirs = $env:CHANGED_DIRS -split ','
        foreach ($dir in $changed_dirs) {
          # Check matrix.json, use default matrix and skip if not found
          # default matrix file located at .github/matrix.json
          $matrixPath = Join-Path -Path $dir -ChildPath "matrix.json"
          if (-not (Test-Path -Path $matrixPath)) {
            Write-Host "No matrix.json found for $dir, using default matrix."
            # Add all targets from default matrix
            $defaultMatrixPath = Get-Content -Path ".github/matrix.json" | Out-String | ConvertFrom-Json
            $matrixInclude = $defaultMatrixPath.include
            break
          } else {
            $matrixContent = Get-Content -Path $matrixPath | Out-String | ConvertFrom-Json
            if (-not $matrixContent.include) {
              continue
            }
            $matrixInclude = $matrixInclude + $matrixContent.include
          }
        }
        # Remove duplicates from matrixInclude
        $matrixInclude = $matrixInclude | Select-Object -Unique -Property target,os
        $matrixJson = @{ include = $matrixInclude } | ConvertTo-Json -Compress
        Write-Host "matrix: $matrixJson"
        echo "matrix=$matrixJson" >> $env:GITHUB_OUTPUT

  ci_build:
    name: Build
    needs: [ci_check, ci_matrix]
    strategy:
      fail-fast: true
      matrix: ${{ fromJson(needs.ci_matrix.outputs.matrix) }}

    runs-on: ${{ matrix.os }}
    if: needs.ci_check.outputs.should_build == 'true'
    steps:
    - name: Checkout Source
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      with:
        ref: ${{ github.head_ref }}
        fetch-depth: 1

    - name: Setup Pixi
      uses: prefix-dev/setup-pixi@a0af7a228712d6121d37aba47adf55c1332c9c2e # v0.9.4
      with:
        cache: true

    - name: Run Build
      id: run_build
      env:
        CHANGED_FILES: ${{ needs.ci_check.outputs.changed_dirs }}
      shell: pwsh
      run: |
        function Assert-LastExitCode([string]$Context) {
          if ($LASTEXITCODE -ne 0) {
            Write-Error "$Context failed with exit code $LASTEXITCODE."
            exit $LASTEXITCODE
          }
        }

        $changed_dirs = $env:CHANGED_FILES -split ','
        foreach ($dir in $changed_dirs) {
          # Check matrix.json and skip if target not found
          $matrixPath = Join-Path -Path $dir -ChildPath "matrix.json"
          if (Test-Path -Path $matrixPath) {
            $matrixContent = Get-Content -Path $matrixPath | Out-String | ConvertFrom-Json
            $shouldTriggerBuild = $false
            foreach ($entry in $matrixContent.include) {
              if ($entry.target -eq "${{ matrix.target }}" -and $entry.os -eq "${{ matrix.os }}") {
                $shouldTriggerBuild = $true
                Write-Host "Explicit build $dir for target ${{ matrix.target }} on OS runner ${{ matrix.os }}"
                break
              }
            }
            if (-not $shouldTriggerBuild) {
              Write-Host "Skipping $dir for target ${{ matrix.target }} on OS runner ${{ matrix.os }}"
              continue
            }
          }

          # Build unpublished dependencies if any
          $unpublishedDepsPath = Join-Path -Path $dir -ChildPath "_deps.txt"
          if (Test-Path -Path $unpublishedDepsPath) {
            # read each line in _deps.txt and build the dependency
            $deps = Get-Content -Path $unpublishedDepsPath | Where-Object { $_ -and -not $_.StartsWith('#') }
            foreach ($dep in $deps) {
              Write-Host "Building unpublished dependency $dep for $dir..."
              pixi run build build --recipe-dir $dep `
                --target-platform ${{ matrix.target }} `
                --log-style plain `
                --skip-existing all `
                -c conda-forge -c chawyehsu
              Assert-LastExitCode "Dependency build $dep"
            }
          }

          Write-Host "Building $dir..."
          pixi run build build --recipe-dir $dir `
            --target-platform ${{ matrix.target }} `
            --log-style plain `
            --skip-existing all `
            -c conda-forge -c chawyehsu
          Assert-LastExitCode "Package build $dir"
        }

        # Generate glob pattern for artifact upload based on changed package names
        $pattern = "[$($changed_dirs -join ',')]"
        Write-Host "Pattern for artifact upload: $pattern"
        echo "pattern=$pattern" >> $env:GITHUB_OUTPUT

    - name: Upload Artifacts
      uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
      with:
        name: ${{ matrix.os }}-${{ matrix.target }}-builds
        path: |
          ./output/${{ matrix.target }}/${{ steps.run_build.outputs.pattern }}*.conda
          ./output/noarch/${{ steps.run_build.outputs.pattern }}*.conda

  cd_release:
    name: Release
    needs: [ci_check, ci_build]
    runs-on: ubuntu-latest
    if: ${{ (github.event_name == 'push' && github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, 'release')) || (github.event_name == 'workflow_dispatch' && github.event.inputs.release == 'true') }}
    steps:
    - name: Checkout Source
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      with:
        ref: ${{ github.head_ref }}
        fetch-depth: 1

    - name: Setup Pixi
      uses: prefix-dev/setup-pixi@a0af7a228712d6121d37aba47adf55c1332c9c2e # v0.9.4
      with:
        cache: true

    - name: Download Artifacts
      uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
      with:
        path: uploads
        merge-multiple: true

    - name: Upload to Anaconda
      env:
        ANACONDA_OWNER: chawyehsu
        ANACONDA_API_KEY: ${{ secrets.ANACONDA_API_KEY }}
        CHANGED_PACKAGES: ${{ needs.ci_check.outputs.changed_dirs }}
      shell: pwsh
      run: | # commit message format: chore(main): release pkg_name v1.2.3
        if (-not $env:ANACONDA_API_KEY -or $env:ANACONDA_API_KEY -eq '') {
          Write-Error "ANACONDA_API_KEY is not set."
          exit 1
        }
        if ($env:CHANGED_PACKAGES) {
          $env:CHANGED_PACKAGES -split ',' | ForEach-Object {
            $files = Get-ChildItem -Path "./uploads/*/$_*.conda"
            Write-Host "Changed package to upload: $_ $($files.Count) files."
            foreach ($file in $files) {
              Write-Host "Uploading $($file.Name)"
              pixi run build upload --log-style plain anaconda "$file"
            }
          }
        }
